-*-outline-*-

-- High priority
* remove case-sensitivity from "for-us?"
  <Black_Dog> Rudybot: check the mirror, silly
  <offby1> ooh, he's case-sensitive.  bummer

* replace ayita?!
  That means coming up with a simple factoid UI.

  I've created a few del.icio.us links tagged with "svnfaq".  Perhaps
  he could:  Hang out in #svn; look for messages that are a single
  word plus a question mark; search for a link of that title,
  belonging to me, with the svnfaq tag.

* single-character attention sequence
  * offby1 wonders if he should create a single-character prefix to get the bot's attention, like
    maybe the comma, so people don't have to spell out "rudybot" all the time
  <eli> offby1: Use `>'!
  <offby1> eli: I was just thinking <.  Weird.
  <eli> No no -- `>'.  Much more better.

* one-click startup
  For people who have never seen it before, provide a shell script
  that connects to freenode with a random nick.  This, of course,
  requires that I write some code to generate a random nick.

* bugs

** deal with this properly
   thread 0: 2007-10-12T21:26:31-0400: Can't parse string from server: ":irc.freenode.net MODE #bots +o ChanServ "

** "quote", "news", and "movie" still provoke multiple responses in query
   I was using version 11M, which has been running on freenode.  I did
   /query rudybot, and then "movie"; it responded five times instead
   of once.  Similarly for "news" and "quote".

   *** rudybot is on channel(s): #emacs #scheme #bots ##cinema 

   I think that I'm creating a new "movie" task for each channel he's
   joined, which is reasonable; but each answers the PRIVMSG directed
   at the bot, in addition to any PRIVMSG directed at the channel.
   It's not clear how to fix this; perhaps only the first such task
   should handle PRIVMSGs directed to the bot.  Or (more sensibly) I
   should only create one such task per session, and have it handle
   all PRIVMSGs, be they directed to channels or to the bot.

** sporadic test failure
   "channel doesn't go idle when we are yammering at it".  No idea
   why, really.  I've refactored the file that test lives in, in the
   hope that that will magically make the problem go away.  I've also
   built a statue to Thoth, the God of software quality.

** Occasional mystery stack trace
   See the file in bug/.

-- Low priority

* dynamically load verbs
  <eli> offby1: Now make verbs like `eval' and `uptime' come from files under the same name in a
        "verb" directory,
  <offby1> dynamically loaded?
  <eli> offby1: Yeah.
  <offby1> yup
  <eli> You could add and remove verbs on demand.

* Find a way to reload code while running
  (Pity this isn't obvious, as in Common Lisp) Eli suggests I look at
  /usr/local/src/langs/scheme/plt/collects/handin-server/private/reloadable.ss

* A way to hack the sandboxes

  Let's say eli is messing with rudybot's "eval" command.  I'd like to
  be able to hop into the repl, and fiddle with that namespace -- say,
  redefine "cons" to display "Eli Barzilay, you have been hax0red" or
  something equally juvenile.

* auto translate, like fsbot
  http://paste.lisp.org/display/48148 is a Python example
  see http://translate.google.com

* bugs

** too many open files
   Around midnight, the bot said "No data from server for a while;
   reconnecting".  No problem.  But then, for the next four hours, it
   tried to reconnect, and failed with ERR_NICKNAMEINUSE; it kept
   trying about twice a minute fruitlessly until around 4:30 AM, at
   which point the logs show 

   thread 0: 2007-09-08T04:27:23-0700:  <= #5(struct:ERR_NICKNAMEINUSE #4(struct:prefix "kubrick.freenode.net" #f) "433" ("*" "rudybot" "Nickname is already in use.") "rudybot")
   thread 0: 2007-09-08T04:27:23-0700:  <= #4(struct:message #4(struct:prefix "kubrick.freenode.net" #f) "451" ("*" "PRIVMSG" "Register first."))
   thread 0: 2007-09-08T04:27:31-0700:  <= #4(struct:message #f "ERROR" ("Closing Link: 127.0.0.1 (Connection Timed Out)"))
   thread 0: 2007-09-08T04:27:31-0700: eof on server; reconnecting
   Caught an exception: #3(struct:exn:fail:filesystem "open-output-file: cannot open output file: \"/var/log/irc-bot/irc.freenode.org-2007-09-08T11:27:41Z\" (Too many open files; errno=24)" #<continuation-mark-set>)

   ... with the above "Caught an exception" message repeated more or
   less endlessly.

** "CTCP source" doesn't return an FTP site :-)

http://www.irchelp.org/irchelp/rfc/ctcpspec.html says that the source
should be hosted on an FTP server, which I don't care to run, so ...

* finer control of logging
  Right now I have a single boolean -- *verbose* -- which controls
  logging.  But it might be nice to have that be a list instead; each
  module would log if and only if it finds on that list a symbol
  assoicated with that module.  That way I could start with the list
  empty, but if I suspected that (say) the moviestowatchfor thread was
  acting funny, I could do, at the repl, something like (add-to-list!
  (*things-to-log*) 'moviestowatchfor)

  If modules were first-class, we could put _them_ on the list
  directly, instead of each module having to create its own symbol
  just for that purpose.

** open log file before threads start
   I often see messages going to stderr even though I've specified
   that they should go to the log file; I assume these messages are
   coming from threads that are running before *log-output-port* gets
   set to the log file.

* read memos?
2007-08-10T15:35:01-0700:  <= #4(struct:message "MemoServ!MemoServ@services." "NOTICE" ("rudybot" "You have a new memo from \u0002offby1\u0002 (#2)"))
2007-08-10T15:35:01-0700:  <= #4(struct:message "MemoServ!MemoServ@services." "NOTICE" ("rudybot" "Type \u0002/msg MemoServ READ 2\u0002 to read it"))

* ack "MODE" at startup
  after we do "/msg nickserv identify" (so that we can send private
  messages on freenode), the server responds with <<:services. MODE
  rudebot :+e>> .  We should note receipt of that message, in case it
  _doesn't_ come and we're wondering why we can't send private
  messages.

** don't log in everywhere?
   I imagine that other IRC networks, besides freenode, either don't
   require logging in, or have a different way of doing it.  We should
   really log in only if we clearly need it

* quotes and news headlines

  I should make the silly quotes have a different period than the news
  headlines, so they don't always arrive together.  This is mostly
  irrelevant, though, since if there's any real chatter in the
  channel, each will get delayed by more-or-less random amounts.

** <j85wilson> 

   offby1: suggestion for rudybot: only have him spew news in a
   channel if there has been speech since the last time he spewed news

* Windows

** Test regularly
   I'd have expected that the repl won't work there, since I try to
   use "readline", and yet it seems ok

* write our own identd server
  like every other IRC client out there.

* reset terminal state on abort
  I notice that, when I abort the terminal in which the bot (and, in
  particular, its repl) is running, I need to type "reset" at the
  shell in order to see characters echo.  This is a bug in mzscheme
  itself
  (http://bugs.plt-scheme.org/query/gnatsweb.pl?cmd=view%20audit-trail&database=default&pr=8836),
  but I should at least work around it.  (elibarzilay says it can't be
  done but I don't believe him)

* Find some way to deal with exceptions in threads
  e.g., "procedure internal-entries-newer-than: expects 3 arguments,
  given 2 ...".  That procedure application is happening in a thread
  other than the main one, and so rather than the whole app dying, it
  just hangs.  This is annoying when I'm running tests -- the tests
  will sometimes pass despite the thread puking.  Naturally I want the
  process to exit with a non-zero status, to ensure that I notice the
  thread dying.

* Convert from strings to bytes
  Wherever possible, change from using "string" procedures to "bytes"
  procedures -- since IRC doesn't specify any character encoding.  As
  things stand now, we're implicitly using UTF-8 everywhere; it'd be
  better for the encoding to be explicit.  That way, eventually I
  could have per-channel encodings.

* maybe periodically see what channels _I'm_ in ...
  (where "I" means "someone with the nick 'offby1'") and have the bot
  join them if it's not already in them.  Like a little puppy dog.
  This is harder than it sounds, since it's not blindingly clear who
  "I" am -- sometimes my nick changes.  It would probably be best to
  find me by host name, not nick.

** brx suggests a "stalk" function
   which takes the name of a victim.  Like the above but oh so
   sinister.

* Catch Control-C so that we don't spew an ugly stack trace when we're killed.
  Maybe even do a nice PART and QUIT while we're at it.

* movies
** Do buubot's job...
  ... find Ebert reviews of movies.  Use IMDB; find the "external
  reviews" link; find Ebert's name.  (I honestly think this would be
  as reliable as searching on rogerebert.com; that site's design is as
  lame as its content is excellent)

** restrict to more recent reviews
   rather than always displaying the 15 most recent, limit to, say,
   those from the last week

* emacschannelquotes
  <e1f> offby1: you need to include emacschannelquotes in rudebot
  He means snag stuff from
  http://www.emacswiki.org/cgi-bin/wiki?EmacsChannelQuotes, but I'd
  rather not do that since most of those quotes are multi-line, and
  wouldn't look good if collapsed.

* eval

** reset
   
   <eli> offby1: BTW, another extension to rudybot: have a way to kill my evaluator, so it will be
         recreated again on the next interaction.
   <eli> So if I do something stupid like:
   <eli> rudybot: eval (define define 1)
   <rudybot> #<void>:""
   <eli> rudybot: eval (define x 1)
   <rudybot> reference to an identifier before its definition: x in module: program
   <eli> then I can restart from a fresh one.


* new commands

** "you suck"
   to emit some TODO list entries, or just a URL to the TODO file

** "help"

** auto shakespeare insults
   I've got scheme code to do that around here somewhere.

** echo URL titles
   the way feck does

* repl commands

I wonder if I should make a new module that contains stuff
specifically for interacting with the bot via the REPL.  It'd be
essentially a full-blown IRC client with a scheme syntax.

** examine a timer
   Maybe have the timers constantly visible in the repl (it'd be nice
   to have curses support to do this).  So I could watch them count
   down.

* "seen" command

** name db after the IRC server
   Or better yet, after the IRC _network_.  So instead of
   "sightings.db", it'd be "freenode-sightings.db"; that way the bot
   could (in theory) be connected to two networks at once, without the
   two dbs interfering with each other.

** truncate output
   because it can be annoyingly long, if the last thing they said was
   annoyingly long.

* respond to jordanb
  <fledermaus> every time jordanb chips in with a "Let's..."
  statement, rudebot should reciprocate.

  Or at least it should squirrel away the quip.

* Terminology
  I suspect there is one RFC-1149-ly correct term for what I variously
  call "requester" and "source" (i.e., the guy who sends an IRC
  message), and other terms.  Try to use the same terms that the RFC
  uses, so that someone who's familiar with the RFC, when reading this
  code, will feel right at home.
