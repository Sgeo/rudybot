    * * * RUDYBOT Evaluation * * *

    ** Introduction **
    This is a log of my thought process as I am exploring the source
    code. An experimental method of investigation to see if it amounts to
    anything.

    An over-the-top, unjustifiably-pedantic and quite possibly ridiculous
    analysis will be found in the following sections of this evaluation.

    Ad lib: REALLY, REALLY over-the-top.

    ** How to Read This Evaluation **
    The questions are the important part. Unfortunately, a great
    proportion of the questions will be stupid and addressed to
    myself. Ignore those.

    ** Terms **
    Stylistic issue: An issue to do with style and personal
    preference. Probably not a real issue.

    ** README.txt **
    What is `version.ss' all about?  Do I do `make' before or after `make
    versions.ss', if it matters?  What's code-coverage analysis?

version.ss lets me include the Subversion revision number in the bot
-- specifically in the global variable *svnversion-string*.  It's
auto-generated, since I can't very well check it in (I'd have to
change it every time I changed anything else).  You create it by doing
"make version.ss", or indeed "make <almost anything>".  You don't
really need to run "make" for any other reason to get the bot working;
the stuff that "make" gets you are more conveniences.  In the
Makefile, the words that appear before a single colon are the
"targets" -- things you can "make".  (Words that come before ":=", on
the other hand, are just variables.)

    What else is there to read about the bot? Is there more information
    about the code?  What's the license? (I know there is the COPYING
    file; but it seems convention to mention it in the README.)

Anything to read about the bot is in some file or other in the source.

The license would probably be GPL or something, if I'd bothered to do
all the proper GPL magic.  Because I'm too lazy, I never bothered
putting the boilerplate at the beginning of each file.

    ** Reading the Code **
    Not sure where to start. Which file is the `main' file, where I can
    figure out how everything works?

I'd start with run-bot.ss, mostly since that's the file you actually
invoke from the command line.

    I'll start with bot.ss

    ** bot.ss **
    To be honest it seems like it REQUIREs a hell of a lot of stuff.

Yup.  Every now and then you'll find that I require something that I
don't actually use, but mostly I really do use all that stuff.

    Personally, I like to mention what each include is for, which is
    probably considered overkill by some, but at least i know exactly how
    something is used.

I really don't want to do that.  Partly out of simple laziness, and
partly out of my hatred of redundancy -- anything I say in that
comment will likely duplicate something that you could easily find in
the package's info.ss.  Plus, if I require the same package in eight
of rudybot's files, do I need to provide the same comment in all eight
of them?  Yuck.

    What's `register-version-string'? Note to self: look this up.

A fair question.  I have this obsession with programs being able to
identify their version with great precision -- many programs will
identify themselves as, say "foobot version 2", and leave it at that,
but I want _way_ more.  I want a number that changes whenever _any_
part of the program changes -- that's what *svnversion-string* does --
but I also want to see version numbers for each constituent file.  So
... register-version-string takes the autogenerated subversion info
for a particular file, and adds it to a list; you see the list
displayed on standard error when you start the bot.

    Okay, *process-start-time* is presumably to see how long rudybot has
    been awake for.

Egg-zackly.

    Bad naming convention on `on-channel?'? Probably stylistic issue.

That function answers the question "was message M uttered on channel
C?"  Can you think of a better name?

    Should `max-output-line' not be an internal definition? 

That is indeed a style thing.  The benefit of an internal definition
is that it doesn't pollute the module namespace ... the disadvantage
is that it'll be harder to notice.  Anyway Eli did that :-)
                                                            
    Are internal definitions slow? 

Nah.
                                   
    Regardless, I think that this should be notated as a constant?
    E.g. +max-output-line+

I have never seen that convention -- +foo+ means "foo is a constant".
Is it widespread?
                          
    and declared somewhere as a shared global?

Now you're suggesting I make it _more_ global than it currently is?

    Sounds like a magic number, in my opinion.

It's semi-magic, and thus deserves a comment, which I've added.

    Why are `pm' and `notice' not using DEFINE's syntactic-sugar?

No good reason at all.

    At first glance check-type looks like some kind of assertion that the
    types are correct. 

Exactly.
                       
    Wondering why one has to pass the procedure
    name--for error displaying? 

Exactly.
                                
    Could this be made into a macro...?

It _is_ a macro :-)  It's defined in the offby1 "PLaneT" package,
which you already have, whether you know it or not.

     (define/asserted-types (pm server (target string?) (msg string?))
        (out server "PRIVMSG ~a :~a" target msg))

Go for it; I'm too lazy to do something like that.  (Besides, it comes
dangerously close to duplicating all the contract machinery, which
I've never learned about)

    First impressions of `respond' procedure: well, I dislike large
    procedures. I don't like to have to scroll up and down to read one
    procedure, but that's a stylistic issue.

Yeah ... it's like the old joke: "I'm sorry that this letter has been
so long; I didn't have enough time to compose a shorter letter"

    Unrelated note: Why is the procedure the *second* argument for
    HASH-TABLE-FOR-EACH?

Don't ask me; ask the PLT guy who designed that function.

    So it seems that you can't really loop through the hash-table properly
    and handle the "not handled" case in a more functional way, 

I sure couldn't think of one.  

                                                                hence the
    `handled?' predicate variable, but... might be worth looking into if
    there's a way to do this without horrible SET!. 

Let's not get our knickers in a twist, here.  Sure, I'm using SET!,
but that's only because I (and, apparently, you) can't think of a
functional way to do it.  And even if there _is_ a functional way, I'd
rather not use it if it's notably more complex than what I've got now.
                                                    
    I reckon one could use continuations but that's going too far, I
    expect.

Yup.  Insanely too far.
                                                      
    Unless one wrapped it up in some nice syntax. 

Not worth it, in my humble opinion.  The odds that I'd actually use
that syntax a second time are mighty slim.
                                                  
    (Wait, why is this a hash-table? I'll have to figure that one
    out...)

See session.ss, line 24.

    So it seems the rest of the code of this procedure is about replying
    when someone says nonsense to rudybot. Indeed, the bulk of the
    procedure appears to be these lists, which, in my opinion could be
    declared as constants globally somewhere, but that's a stylistic
    issue.

Probably a good idea, though.

    (define *sess* #f)

    Eek! Global variable again... What's it do? ... After further
    inspection, that's the global server session structure? 

Yup.  It's gotta go somewhere.  Since right now the bot is only
capable of talking to one server at a time, I have no problem with
this thing being global.  The alternative is to add an extra argument
to every function that needs access to it, which is ugly.
                                                            
    Provided as an
    external object in the module, I'm guessing another module assigns a
    value to it.

The assignment happens in bot.ss -- in fact, in general PLT prevents
one module from assigning to a variable that was defined in another.
*sess* is exported only because the repl needs access to it.

    Now... `register-usual-services!' is a bloody great procedure. But I
    think I can handle it. 

Aw, I thought you meant "great" as in "wonderful" :-)

    I see that you've split `register-usual-services!' into separate
    procedures, and for that I am thankful, har har.

I still think it's too big, but there you go.

    My impression is that `make-channel-action' is a higher order
    procedure which handles a message with the provided `discriminator'
    and then evaluates the `action' when the discriminator returns
    true. 

Precisely

    I'm not sure why `RPL_ENDOFNAMES?' is capitalised as such, 

Because that's a term from the relevant RFC.
                                                               
    but I'm guessing that's the cue for "I've joined a channel!" 

Yup

    Ahh. So this "registering" business is about adding sort of "handlers"
    for IRC events. 

Yup

    I'm guessing the spewer code is the thing for ##cinema? Fairly
    straight-forward.

Other channels too, but yes.

    I'm in `consume-and-spew'. What does `wrapper' do? Is that a
    semaphore grabber? Hmm.

Lemme see ... yup, what the comment says.

That function took a _lot_ of time to get right; I think it, or stuff
related to it, was the single most difficult thing I did.

    Ahh. Hmmmm. If I'm reading this correctly... `consume-and-spew' gives
    `exponentially-backing-off-spewer' a procedure that it can use to
    create a thread with. And the procedure used to create that thread has
    a static-duration variable `delay', and also, when executed, adds a
    "handler" to the server for people's chatting. Assuming `chatter?'
    returns true at people saying -anything-, or at least anything not a
    bot command, each time someone says something, rudybot decides to wait
    another n seconds/minutes where n is (*minimum-delay-for-periodic-spew*).

    Additionally, this delay is increased each time it says
    something... Although I don't follow that. Must be reading it wrongly.

I think I'm trying to make it behave like this:

* when there's no "chatter" -- talk of any kind -- on the channel, it
  should "spew" something every now and then.

* "every now and then" means something like "the first time, after
  some delay; each subsequent time, after twice that delay".

* as soon as someone else says something, reset the delay.

I actually don't think I got this quite right, but it's OK; the point
was to get it to say moderately interesting stuff (like Emacs news, or
movie recommendations) often enough to be informative, but not so
often as to be annoying.  Took a bunch of fiddling, and other IRC
denizens roundly flamed me when it was too frequent.

    Okay, when we're in the #svn channel it installs something that
    listens for... some sort of relevant post thing. 

Gaah.  Anything that's specific to #svn is cruft; I've nixed it.
That's there because at one point I wanted rudybot to replace "ayita",
the bot who normally lives there.  But someone else wrote (from
scratch!  The bastard) an excellent replacement in about two days,
which is now happily running.

    So for #emacs, #bots and #scheme-bots it produces funny quotes. I'm
    getting the hang of this.

Yay.  Note that in those channels it produces the funny quotes
_unprompted_; it will produce a funny quote in _any_ channel if you
say "quote" to it.

    Hmmm. I'm thinking... that it would perhaps be nice to make the (add!
    ..) construct into a macro? 

Probably, to save you typing all them lambdas.

    I can't tell. It seems like these handler
    definitions should be among procedure definitions, not sort of hidden
    inside another procedure. 

I think I disagree -- they're only used in that one place (namely, the
call to "add!"), so there's no need to make them more visible.
                              
    I'm not sure. I like eli's method of putting the handlers in
    separate files which are read at initialisation time. That's
    pretty good? 

I _love_ that idea, but doing that would be a very large change (I
think), and I haven't yet (after a month or so of trying) worked up
the courage to start that work.

That's what I meant recently when I said "you should combine the best
of eli's bot and mine" -- I was more or less serious.  The good parts
of his bot are the clean structure -- including putting those handlers
in separate files, which automatically get reloaded; the good parts,
if any, of rudybot, are the amusing quotes, and feed-reading.
